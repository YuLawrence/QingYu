<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>纪念伟大领袖毛主席</title>
    <link href="/2021/09/09/%E4%BC%9F%E5%A4%A7%E9%A2%86%E8%A2%96/"/>
    <url>/2021/09/09/%E4%BC%9F%E5%A4%A7%E9%A2%86%E8%A2%96/</url>
    
    <content type="html"><![CDATA[<h1 id="值伟大领袖逝世-45-周年之际，谨以最崇高的敬意怀念毛主席"><a href="#值伟大领袖逝世-45-周年之际，谨以最崇高的敬意怀念毛主席" class="headerlink" title="值伟大领袖逝世 45 周年之际，谨以最崇高的敬意怀念毛主席"></a>值伟大领袖逝世 45 周年之际，谨以最崇高的敬意怀念毛主席</h1>]]></content>
    
    
    <categories>
      
      <category>有感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>伟大领袖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList、LinkedList和Vector的区别</title>
    <link href="/2021/08/30/ArrayList%E3%80%81LinkedList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/08/30/ArrayList%E3%80%81LinkedList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>ArrayList、LinkedList 和 Vector 的区别</strong></p><h3 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h3><blockquote><p>相同点</p></blockquote><p>这三个类都实现了 Collection 接口，存储数据的特点相同：存储有序的、可重复的数据</p><blockquote><p>不同点</p></blockquote><ol><li>ArrayList 作为 List 接口的主要实现类，线程不安全，效率高，底层使用 Object[] elementData 存储</li><li>LinkedList 对于频繁的插入、删除操作，使用此类效率比 ArrayList 高，底层使用双向链表存储</li><li>Vector 作为 List 接口古老实现类，线程安全，效率低，底层使用 Object[] elementData 存储</li></ol><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><ul><li>ArrayList</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">JDK7:<br>ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<span class="hljs-comment">// 底层创建了长度是10的Object[]数组elementData</span><br>list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">// elementData[0] = new Integer(123);</span><br>...<br>list.add(<span class="hljs-number">11</span>);<span class="hljs-comment">// 如果此次的添加导致底层elementData数组容量不够，则扩容。</span><br><span class="hljs-comment">// 默认情况下，扩容为原来容量的1.5倍，同时将原有数组中的数据复制到新的数组中。</span><br><span class="hljs-comment">// 建议：如果知道存储的元素数量，使用带参数的构造器，避免自动扩容，提高效率</span><br>ArrayList list = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">int</span> capacity);<br><br>JDK8：<br>ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<span class="hljs-comment">// 底层Object[]数组elementData初始化为&#123;&#125;，并没有创建长度为10的数组</span><br>list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">// 第一次调用add()方法时，底层才创建了长度是10数组，并将数据123添加到elementData中</span><br><span class="hljs-comment">// 后续添加和扩容操作和JDK7无异</span><br><br><span class="hljs-comment">// jdk7中ArrayList的创建类似于单例的饿汉式，而jdk8中的ArrayList的创建类似于单例的懒汉式，延迟了数组的创建，节省了内存。</span><br></code></pre></td></tr></table></figure><ul><li>LinkedList</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>LinkedList list = <span class="hljs-keyword">new</span> LinkedList();<span class="hljs-comment">// 内部声明了Node类型的first和last属性，默认值是null</span><br>list.add(<span class="hljs-number">123</span>)<span class="hljs-comment">// 将123添加到Node中，创建了Node对象</span><br><span class="hljs-comment">// 其中，Node定义为：即双向链表结构</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>Vector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组；</span><br><span class="hljs-comment">// 在扩容方面，默认扩容为原来数组的2倍</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试经验</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java容器类详解</title>
    <link href="/2021/08/17/Java%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/17/Java%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>源于尚硅谷视频教程总结的笔记</li><li>推荐去看视频教程：<a href="https://www.bilibili.com/video/BV1Kb411W75N">https://www.bilibili.com/video/BV1Kb411W75N</a></li></ul></blockquote><hr><p><strong>集合、数组都是对多个数据进行存储操作的结构，简称Java容器</strong></p><blockquote><p>先寄出这张经典老图</p></blockquote><p><img src="https://gitee.com/YuLawrence/picture/raw/master/202110/20211005_215826875_0.png" alt="image-20211005215546519"></p><hr><blockquote><p>Java 容器类主要分为以下两类：</p></blockquote><h3 id="一、Collection"><a href="#一、Collection" class="headerlink" title="一、Collection"></a>一、Collection</h3><blockquote><p>常用方法，注：向Collection接口的实现类的对象中添加数据obj时，一般要求obj所在类要重写equals()</p></blockquote><ul><li>contains(Object obj)：判断当前集合是否包含obj</li><li>containsAll(Collection list1)：判断list1中存在的元素是否都存在当前集合中</li><li>remove(Object obj)：从当前集合中移除obj元素</li><li>removeAll(Collection list1)：从当前集合中移除list1中的所有元素</li><li>retainAll(Collection list1)：交集：获取当前集合和list1集合的交集，并返回给当前集合</li><li>equals(Object obj)：判断当前形参和当前集合的元素是否相同，如果实现Collection的是ArrayList类，则顺序也要一致才会返回true；</li><li>hashCode()：返回当前对象的哈希值</li><li>toArray()：将集合转换为数组 ————————&gt; 拓展：将数组转化为集合，调用Array类的静态方法asList()</li><li>iterator()：返回iterator接口的实例，用于遍历集合的元素</li></ul><h4 id="1-List：有序的、可重复的"><a href="#1-List：有序的、可重复的" class="headerlink" title="1.List：有序的、可重复的"></a>1.List：有序的、可重复的</h4><ul><li><p><strong>ArrayList</strong></p></li><li><p><strong>LinkedList</strong></p></li><li><p><strong>Vector</strong></p></li></ul><blockquote><p>List接口的常用方法</p></blockquote><ul><li>void add(intindex, Object ele):在index位置插入ele元素</li><li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li><li>Object get(int index):获取指定index位置的元素</li><li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li><li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li><li>Object remove(int index):移除指定index位置的元素，并返回此元素</li><li>Object set(int index, Object ele):设置指定index位置的元素为ele</li><li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * List接口的常用方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * void add(int index, Object ele):在index位置插入ele元素</span><br><span class="hljs-comment">     * boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br><span class="hljs-comment">     * Object get(int index):获取指定index位置的元素</span><br><span class="hljs-comment">     * int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br><span class="hljs-comment">     * int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br><span class="hljs-comment">     * Object remove(int index):移除指定index位置的元素，并返回此元素</span><br><span class="hljs-comment">     * Object set(int index, Object ele):设置指定index位置的元素为ele</span><br><span class="hljs-comment">     * List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 总结：常用方法</span><br><span class="hljs-comment">     * 增：add(Object obj)</span><br><span class="hljs-comment">     * 删：remove(int index)：List接口重载的删除方法 / remove(Object obj)：collection接口中的</span><br><span class="hljs-comment">     * 改：set(int index, Object ele)</span><br><span class="hljs-comment">     * 查：get(int index)</span><br><span class="hljs-comment">     * 插：add(int index, Object ele)</span><br><span class="hljs-comment">     * 长度：size()</span><br><span class="hljs-comment">     * 遍历：① Iterator迭代器方式</span><br><span class="hljs-comment">     *      ② 增强for循环</span><br><span class="hljs-comment">     *      ③ 普通的循环</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>        ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br>        list.add(<span class="hljs-number">123</span>);<br>        list.add(<span class="hljs-number">456</span>);<br>        list.add(<span class="hljs-string">&quot;AA&quot;</span>);<br><br>        <span class="hljs-comment">//方式一：Iterator迭代器方式</span><br>        Iterator iterator = list.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            System.out.println(iterator.next());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;***************&quot;</span>);<br><br>        <span class="hljs-comment">//方式二：增强for循环</span><br>        <span class="hljs-keyword">for</span>(Object obj : list)&#123;<br>            System.out.println(obj);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;***************&quot;</span>);<br><br>        <span class="hljs-comment">//方式三：普通for循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; list.size();i++)&#123;<br>            System.out.println(list.get(i));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tets2</span><span class="hljs-params">()</span></span>&#123;<br>        ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br>        list.add(<span class="hljs-number">123</span>);<br>        list.add(<span class="hljs-number">456</span>);<br>        list.add(<span class="hljs-string">&quot;AA&quot;</span>);<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">12</span>));<br>        list.add(<span class="hljs-number">456</span>);<br>        <span class="hljs-comment">//int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.</span><br>        <span class="hljs-keyword">int</span> index = list.indexOf(<span class="hljs-number">4567</span>);<br>        System.out.println(index);<br><br>        <span class="hljs-comment">//int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.</span><br>        System.out.println(list.lastIndexOf(<span class="hljs-number">456</span>));<br><br>        <span class="hljs-comment">//Object remove(int index):移除指定index位置的元素，并返回此元素</span><br>        Object obj = list.remove(<span class="hljs-number">0</span>);<br>        System.out.println(obj);<br>        System.out.println(list);<br><br>        <span class="hljs-comment">//Object set(int index, Object ele):设置指定index位置的元素为ele</span><br>        list.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;CC&quot;</span>);<br>        System.out.println(list);<br><br>        <span class="hljs-comment">//List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合</span><br>        List subList = list.subList(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>        System.out.println(subList);<br>        System.out.println(list);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br>        list.add(<span class="hljs-number">123</span>);<br>        list.add(<span class="hljs-number">456</span>);<br>        list.add(<span class="hljs-string">&quot;AA&quot;</span>);<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">12</span>));<br>        list.add(<span class="hljs-number">456</span>);<br><br>        System.out.println(list);<br><br>        <span class="hljs-comment">//void add(int index, Object ele):在index位置插入ele元素</span><br>        list.add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;BB&quot;</span>);<br>        System.out.println(list);<br><br>        <span class="hljs-comment">//boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br>        List list1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        list.addAll(list1);<br><span class="hljs-comment">//        list.add(list1);</span><br>        System.out.println(list.size());<span class="hljs-comment">//9</span><br><br>        <span class="hljs-comment">//Object get(int index):获取指定index位置的元素</span><br>        System.out.println(list.get(<span class="hljs-number">2</span>));<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>关于remove()方法的面试题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListEver</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 区分List中remove(int index)和remove(Object obj)</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testListRemove</span><span class="hljs-params">()</span> </span>&#123;<br>        List list = <span class="hljs-keyword">new</span> ArrayList();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        updateList(list);<br>        System.out.println(list);<span class="hljs-comment">//</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateList</span><span class="hljs-params">(List list)</span> </span>&#123;<br>        <span class="hljs-comment">// 此处调用的事remove(int index)的方法</span><br><span class="hljs-comment">//        list.remove(2);</span><br>        <span class="hljs-comment">// 此处调用的事remove(Object obj)的方法</span><br>        list.remove(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Set：无序的、不可重复的"><a href="#2-Set：无序的、不可重复的" class="headerlink" title="2.Set：无序的、不可重复的"></a>2.Set：无序的、不可重复的</h4><blockquote><ul><li>Set接口中没有定义新的方法，使用的都是collection中声明过的方法</li><li>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</li><li>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</li><li>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li></ul></blockquote><h5 id="2-1-HashSet：作为Set接口的主要实现类，线程不安全，可以存储null值"><a href="#2-1-HashSet：作为Set接口的主要实现类，线程不安全，可以存储null值" class="headerlink" title="2.1 HashSet：作为Set接口的主要实现类，线程不安全，可以存储null值"></a>2.1 <strong>HashSet</strong>：作为Set接口的主要实现类，线程不安全，可以存储null值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.无序性：不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值</span><br><span class="hljs-comment">//2.不可重复性：保证添加的元素按照equals()方法判断时，不能返回true，即相同的元素只能添加一个</span><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 二、添加元素的过程：以HashSet为例：</span><br><span class="hljs-comment"> *      我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span><br><span class="hljs-comment"> *      此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</span><br><span class="hljs-comment"> *      数组此位置上是否已经有元素：</span><br><span class="hljs-comment"> *          如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1</span><br><span class="hljs-comment"> *          如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</span><br><span class="hljs-comment"> *              如果hash值不相同，则元素a添加成功。---&gt;情况2</span><br><span class="hljs-comment"> *              如果hash值相同，进而需要调用元素a所在类的equals()方法：</span><br><span class="hljs-comment"> *                    equals()返回true,元素a添加失败</span><br><span class="hljs-comment"> *                    equals()返回false,则元素a添加成功。---&gt;情况3</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span><br><span class="hljs-comment"> *      jdk 7 :元素a放到数组中，指向原来的元素。</span><br><span class="hljs-comment"> *      jdk 8 :原来的元素在数组中，指向元素a</span><br><span class="hljs-comment"> *      总结：七上八下</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * HashSet底层：数组+链表的结构。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><blockquote><p>IDE中对hashCode()方法的重写，为什么用31这个数字？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> prime = <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br>    result = prime * result + ((id == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : id.hashCode());<br>    result = prime * result + ((name == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : name.hashCode());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</span><br><span class="hljs-comment"> * 并且31只占用5bits,相乘造成数据溢出的概率较小。</span><br><span class="hljs-comment"> * 31可以由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</span><br><span class="hljs-comment"> * 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li><strong>LinkedHashSet</strong>：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LinkedHashSet是HashSet的子类</span><br><span class="hljs-comment"> * LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入序保存的。</span><br><span class="hljs-comment"> * LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。</span><br><span class="hljs-comment"> * LinkedHashSet不允许集合元素重复。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h5 id="2-2-TreeSet：可以按照添加的对象的指定属性，进行排序"><a href="#2-2-TreeSet：可以按照添加的对象的指定属性，进行排序" class="headerlink" title="2.2 TreeSet：可以按照添加的对象的指定属性，进行排序"></a>2.2 <strong>TreeSet</strong>：可以按照添加的对象的指定属性，进行排序</h5><ol><li>向TreeSet中添加数据，要求是相同类的对象</li><li>两种排序方式：自然排序（实现Comparable接口）和自定义排序（Comparator）</li><li>自然排序中，比较两个对象是否有相同的标准：compareTo()返回0，不是equals().</li><li>定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</li></ol><h4 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3.Queue"></a>3.Queue</h4><h3 id="二、Map：双列数据，存储Key-Value对的数据"><a href="#二、Map：双列数据，存储Key-Value对的数据" class="headerlink" title="二、Map：双列数据，存储Key-Value对的数据"></a>二、Map：双列数据，存储Key-Value对的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; 要求key所在的类要重写equals()和hashCode() （以HashMap为例）</span><br><span class="hljs-comment"> *  Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()</span><br><span class="hljs-comment"> *  一个键值对：key-value构成了一个Entry对象。</span><br><span class="hljs-comment"> *  Map中的entry:无序的、不可重复的，使用Set存储所有的entry</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="1-HashMap：Map的主要实现类：线程不安全的，效率高，可以存储null的key和value"><a href="#1-HashMap：Map的主要实现类：线程不安全的，效率高，可以存储null的key和value" class="headerlink" title="1.HashMap：Map的主要实现类：线程不安全的，效率高，可以存储null的key和value"></a>1.<strong>HashMap</strong>：Map的主要实现类：线程不安全的，效率高，可以存储null的key和value</h4><blockquote><p>HashMap的底层：数组+链表（jdk7及以前），数组+链表+红黑树（jdk8）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap的底层实现原理：<br>JDK7：<br>HashMap hashMap = <span class="hljs-keyword">new</span> HashMap(); <span class="hljs-comment">// 在实例化以后，底层创建了长度是16的一维数组Entry[] table。</span><br>hashMap.put(<span class="hljs-string">&quot;xxx&quot;</span>,xxx);<br>...可能已经执行多次put...<br>    hashMap.put(key,value);<br>        首先，调用key所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。<br>        如果此位置上的数据为空，此时的key-value添加成功。---情况<span class="hljs-number">1</span><br>        如果此位置上的数据不为空，意味着此位置上有一个或多个数据（以链表形式存在），比较key和已存在的一个或多个数据的哈希值：<br>            如果key的哈希值与已经存在的数据的哈希值都不相同，此时key-value添加成功。---情况<span class="hljs-number">2</span><br>            如果key的哈希值与已经存在的某个数据(key1,value1)的哈希值相同，继续比较：调用key所在类的equals()方法，比较：<br>            如果equals()返回<span class="hljs-keyword">false</span>：此时key-value添加成功。---情况<span class="hljs-number">3</span><br>            如果equals()返回<span class="hljs-keyword">true</span>：使用value替换value1。<br>            <br>    注：关于情况<span class="hljs-number">2</span>和清空<span class="hljs-number">3</span>：此时的key-value和原来的数据以链表的方式存储<br>            <br>        在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的<span class="hljs-number">2</span>倍，并将原有的数据复制过来。<br><br>JDK8 相较于JDK7在底层的实现方面的不通：<br><span class="hljs-number">1.</span><span class="hljs-function">new <span class="hljs-title">HashMap</span><span class="hljs-params">()</span>：底层没有创建一个长度为16的数组。</span><br><span class="hljs-function">2.JDK8底层的数组是Node[],而非Entry[]</span><br><span class="hljs-function">3.在首次调用<span class="hljs-title">put</span><span class="hljs-params">()</span>方法时，底层创建长度为16的数组</span><br><span class="hljs-function">4.JDK7的底层结构只有：数组+链表。JDK8中结构：数组+链表+红黑树。</span><br><span class="hljs-function">        当数组的某一个索引位置上的元素以链表的形式存在的个数 &gt; 8 且当前数组长度 &gt;64,此时此索引位置上的所数据改为使用红黑树存储。</span><br><span class="hljs-function"></span><br><span class="hljs-function">            </span><br></code></pre></td></tr></table></figure><ul><li><strong>LinkedHashMap</strong>：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率优于HashMap</li></ul><h4 id="2-HashTable：古老的实现类，线程安全，效率低，不能存储null的key和value"><a href="#2-HashTable：古老的实现类，线程安全，效率低，不能存储null的key和value" class="headerlink" title="2.HashTable：古老的实现类，线程安全，效率低，不能存储null的key和value"></a>2.<strong>HashTable</strong>：古老的实现类，线程安全，效率低，不能存储null的key和value</h4><ul><li> <strong>Properties</strong>：常用用来处理配置文件，key和value都是String类型</li></ul><h4 id="3-TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或自定义排序，底层使用红黑树"><a href="#3-TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或自定义排序，底层使用红黑树" class="headerlink" title="3.TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或自定义排序，底层使用红黑树"></a>3.<strong>TreeMap</strong>：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或自定义排序，底层使用红黑树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象，因为要按照key进行排序：自然排序和自定义排序</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试经验</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java容器类</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Oracle插入纪录如何同时返回主键</title>
    <link href="/2021/08/17/%E5%85%B3%E4%BA%8EOracle%E6%8F%92%E5%85%A5%E7%BA%AA%E5%BD%95%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE/"/>
    <url>/2021/08/17/%E5%85%B3%E4%BA%8EOracle%E6%8F%92%E5%85%A5%E7%BA%AA%E5%BD%95%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天上午开发中遇到的一个问题，之前也确实没有使用，写了好久才解决。</p></blockquote><h3 id="1-问题由来"><a href="#1-问题由来" class="headerlink" title="1.问题由来"></a>1.问题由来</h3><p>前端需要在调用插入方法后获取相应的 id 主键。使用的是 Oracle 的数据库，Oracle 的主键是采用序列自增的。</p><h3 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">insert</span> id<span class="hljs-operator">=</span>&quot;id&quot; parameterType<span class="hljs-operator">=</span>&quot;com.lawrence.entity.User&quot; useGeneratedKeys<span class="hljs-operator">=</span>&quot;true&quot; keyProperty<span class="hljs-operator">=</span>&quot;id&quot; <span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span>selectKey resultType<span class="hljs-operator">=</span>&quot;java.lang.Integer&quot; <span class="hljs-keyword">order</span><span class="hljs-operator">=</span>&quot;BEFORE&quot; keyProperty<span class="hljs-operator">=</span>&quot;id&quot;<span class="hljs-operator">&gt;</span><br>        <span class="hljs-keyword">select</span> SEQ_USER.nextval <span class="hljs-keyword">as</span> id <span class="hljs-keyword">from</span> DUAL<br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>selectKey<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">User</span>(ID,NAME)<br>    <span class="hljs-keyword">values</span>(#&#123;id&#125;,#&#123;name&#125;)<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">insert</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-用到的关键字解释："><a href="#3-用到的关键字解释：" class="headerlink" title="3.用到的关键字解释："></a>3.用到的关键字解释：</h3><ul><li>useGeneratedKeys=”true” ：使用自动增长的主键</li><li>keyProperty=”id” ：将返回值赋给指定的列</li><li>order=”before” ：设置 selectKey 中包含的语句先执行</li></ul><h3 id="4-具体应用"><a href="#4-具体应用" class="headerlink" title="4.具体应用"></a>4.具体应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Systemt.out.println(user.getId);      <span class="hljs-comment">// 此时插入前主键为空值</span><br>userMapper.insertUser(user);<br>Systemt.out.println(user.getId);      <span class="hljs-comment">// 此时的ID已经为插入后的主键</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Oracle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遍历循环遇到的问题</title>
    <link href="/2021/08/16/%E9%81%8D%E5%8E%86%E5%BE%AA%E7%8E%AF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/16/%E9%81%8D%E5%8E%86%E5%BE%AA%E7%8E%AF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天又是蠢蠢的一天，再再再再一次因为写错导致排查半天的错误</p></blockquote><h3 id="1-话不多说，直接复现了一下问题"><a href="#1-话不多说，直接复现了一下问题" class="headerlink" title="1.话不多说，直接复现了一下问题"></a>1.话不多说，直接复现了一下问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">questionnair</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 错误写法：循环体外复用一个对象</span><br>        <span class="hljs-comment">// User user = new User();</span><br>        User user;<br>        List&lt;User&gt; userList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 正确写法 或 方案一：User user = new User();</span><br>            <span class="hljs-comment">// 方案二</span><br>            user = <span class="hljs-keyword">new</span> User();<br>            user.setId(i);<br>            user.setName(<span class="hljs-string">&quot;你猜&quot;</span> + i);<br>            userList.add(user);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (User user2 : userList) &#123;<br>            System.out.println(user2);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Integer id;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> id;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.id = id;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-打印结果"><a href="#2-打印结果" class="headerlink" title="2.打印结果"></a>2.打印结果</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autoit">错误结果：此时想要的集合元素其实都是同一个对象；<br>questionnair$User<span class="hljs-symbol">@368239c8</span><br>questionnair$User<span class="hljs-symbol">@368239c8</span><br>questionnair$User<span class="hljs-symbol">@368239c8</span><br>questionnair$User<span class="hljs-symbol">@368239c8</span><br>questionnair$User<span class="hljs-symbol">@368239c8</span><br><br>正确结果：明显可以看出 这是正确放入集合中的元素<br>questionnair$User<span class="hljs-symbol">@368239c8</span><br>questionnair$User<span class="hljs-symbol">@9e89d68</span><br>questionnair$User<span class="hljs-symbol">@3b192d32</span><br>questionnair$User<span class="hljs-symbol">@16f65612</span><br>questionnair$User<span class="hljs-symbol">@311d617d</span><br></code></pre></td></tr></table></figure><h3 id="3-出现这种问题的原因所在："><a href="#3-出现这种问题的原因所在：" class="headerlink" title="3.出现这种问题的原因所在："></a>3.出现这种问题的原因所在：</h3><ol><li><p>我的想法：</p><p>首先我想的是虽然都是同一个对象，但是我每次赋的都是新值且赋值前都放入了集合中，“按理说”应该是不同的元素。</p></li><li><p>实际上：</p><p>因为只 new 了一个对象，所以在内存中只为这一个对象开辟了存储空间。而实例变量 user 是指向该对象存储空间的地址，例如 0X12345。当 i = 1 时，赋给它的值为 1；id = 1,name = “你猜 1”；虽然在下一轮循环中，重新赋了值，即 id = 2,name = “你猜 2”；但是放入集合中的两个元素，其实都是指向 0X12345，所以 list 中的元素 都是最新的同一个对象，自然就不是想要的结果。</p></li><li><p>正确的原因</p><p>同理可知，每次循环 new 一个对象，并赋予它不同的值，得到的结果自然是不通的对象。不过需要注意的是，在循环体中声明对象，如方案一的方法 每次循环都会创建一份对象引用，如果循环次数就会非常消耗内存，更深的细节就设计 Jvm 底层远离了，就不做更多的叙述了，有兴趣了解的可以去查阅一下。</p></li></ol><blockquote><p>涉及到的知识点：Java 的值传递和对象地址传递，都是一些很基础的知识点，由此可见基础对于开发的重要性；</p></blockquote><h3 id="4-有更多理解和有错误所在的请不吝讲解，相互学习。"><a href="#4-有更多理解和有错误所在的请不吝讲解，相互学习。" class="headerlink" title="4.有更多理解和有错误所在的请不吝讲解，相互学习。"></a>4.有更多理解和有错误所在的请不吝讲解，相互学习。</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
      <tag>for循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle 中 nvl 的用法</title>
    <link href="/2021/08/10/Oracle%E4%B8%ADnvl%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2021/08/10/Oracle%E4%B8%ADnvl%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下平时简单开发中用到的 nvl 函数，加深对 Oracle 常用函数的理解。</p></blockquote><h3 id="1-nvl-的定义（来源于百科）"><a href="#1-nvl-的定义（来源于百科）" class="headerlink" title="1.nvl()的定义（来源于百科）"></a>1.nvl()的定义（来源于百科）</h3><p><a href="https://baike.baidu.com/item/NVL">NVL</a>(E1, E2)的功能为：如果 E1 为 NULL，则函数返回 E2，否则返回 E1 本身。但此函数有一定局限，所以就有了 NVL2 函数。</p><p>拓展：NVL2 函数:Oracle/PLSQL 中的一个函数,Oracle 在 NVL 函数的功能上扩展，提供了 NVL2 函数。<a href="https://baike.baidu.com/item/NVL">NVL</a>2(E1, E2, E3)的功能为：如果 E1 为 NULL，则函数返回 E3，若 E1 不为 null，则返回 E2。</p><h3 id="2-nvl-的格式和用法"><a href="#2-nvl-的格式和用法" class="headerlink" title="2.nvl 的格式和用法"></a>2.nvl 的格式和用法</h3><p>nvl(E1,E2);</p><p>要注意 E1 和 E2 的类型要一致，nvl 支持的返回值类型有字符型、日期型、日期时间型、数值型、货币型、逻辑型和 null 值。</p><ul><li>用途一：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">user</span>&#123;id,name&#125;<br><span class="hljs-keyword">select</span> id,nvl(name,&quot;张三&quot;) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>在对所查询的字段使用 nvl，如果查询出来的结果为空值，则返回”张三“。自己在开发中，对于数据库里一些状态字段的数据，有时有的记录没有值但又需要该字段来进行判断，则可以将字段值为 1 的与字段值为 0 或 null 值的区分开来。</p><ul><li>用途二：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">user</span>&#123;id,name&#125;<br><span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> nvl(id,<span class="hljs-number">0</span>) <span class="hljs-operator">=</span> #&#123;id&#125;<br></code></pre></td></tr></table></figure><p>一开始使用也是在这里用的多，同事写的查询方法只查了某个值 = 1 的记录，但是数据库里其他很多记录是 null，在前端显示的话就没有数据，排查出来后就是加了 nvl 函数，如果数据库里有该 id 的记录则正常查询，否则返回该字段为 0;</p><blockquote><p>后续若有其他理解感悟，再回来补充。若有大佬觉得哪里有问题，请不吝赐教。QAQ</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Oracle</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/05/hello-world/"/>
    <url>/2021/07/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bugs</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
